# Story 3.2: Real-Time Event Processor

## Status
- Approved

## Story
**As a** developer,
**I want** a processor that consumes resource events and applies the corresponding changes to the Neo4j graph,
**so that** the graph remains a consistent, real-time reflection of the cluster state.

## Acceptance Criteria
1. A function `StartEventProcessor` is created that listens for events on the channel provided by the SSE client.
2. For an `add` event, the processor uses the mapping logic (from Story 2.2) and the `Neo4jClient` to `MERGE` the new node and its relationships into the graph.
3. For an `update` event, the processor uses the `Neo4jClient` to `MERGE` the node's new properties and re-evaluates its relationships, adding or removing them as needed.
4. For a `delete` event, the processor uses the `Neo4jClient` to execute a `DETACH DELETE` query to remove the node and all its relationships.
5. Each event processed is tracked within its own OpenTelemetry trace.
6. Unit tests are written for the processor logic for each event type (`add`, `update`, `delete`), mocking the `Neo4jClient`.
7. An integration test verifies that when an event is sent to the input channel, the correct change is persisted in the test Neo4j database.

## Tasks / Subtasks
- [ ] Task 1: Implement Event Processor Function (AC: 1)
  - [ ] In `internal/processor/processor.go`, implement the `StartEventProcessor` function.
  - [ ] This function should take a channel of `kubeview.Event` as input.
- [ ] Task 2: Handle `add` and `update` Events (AC: 2, 3)
  - [ ] Add a case to the event processor to handle `add` and `update` events.
  - [ ] For these events, call the `KubernetesResourceToNode` and `ExtractRelationships` functions.
  - [ ] Use the `Neo4jClient` to `MERGE` the resulting node and relationships.
- [ ] Task 3: Handle `delete` Events (AC: 4)
  - [ ] Add a case to handle `delete` events.
  - [ ] Use the `Neo4jClient` to execute a `DETACH DELETE` query based on the resource `uid`.
- [ ] Task 4: Add OpenTelemetry Instrumentation (AC: 5)
  - [ ] Create a new span for each event that is processed.
- [ ] Task 5: Write Unit and Integration Tests (AC: 6, 7)
  - [ ] In `internal/processor/processor_test.go`, add unit tests for the event handling logic, mocking the `Neo4jClient`.
  - [ ] Add an integration test that sends events to the processor and verifies the changes in a Testcontainers Neo4j instance.

## Dev Notes

### File Locations & Structure
- `internal/processor/processor.go` (Modified)
- `internal/processor/processor_test.go` (Modified)

[Source: docs/architecture/09-source-tree.md]

### Component Dependencies
- The `processor` depends on the `graph` and `neo4j` components.

[Source: docs/architecture/05-components.md]

### Data Consistency
- Use `MERGE` for `add`/`update` operations and `DETACH DELETE` for `delete` operations.

[Source: docs/architecture/11-error-handling-strategy.md]

### Coding Standards
- **Language:** Go 1.24.6
- **Concurrency:** The event processor will run in its own goroutine.

[Source: docs/architecture/12-coding-standards.md]

### Testing
- **Unit Tests:** Mock the `Neo4jClient` to test the logic for each event type.
- **Integration Tests:** Use a real Neo4j instance (via Testcontainers) to verify the end-to-end event processing flow.

[Source: docs/architecture/13-test-strategy-and-standards.md]

## Change Log

| Date       | Version | Description                | Author |
| :--------- | :------ | :------------------------- | :----- |
| 2025-09-18 | 1.0     | Initial draft of the story. | Bob    |
